{\rtf1\ansi\ansicpg1252\deff0\deflang3084{\fonttbl{\f0\fnil\fcharset0 Calibri;}}
{\*\generator Msftedit 5.41.21.2510;}\viewkind4\uc1\pard\sa200\sl276\slmult1\lang9\f0\fs22 using UnityEngine;\par
using System.Collections;\par
using System;\par
using System.Linq;\par
\par
public class TunnelWaver : MonoBehaviour \{\par
\tab\par
\tab private float hauteurAigues;\par
\tab private float hauteurBasses;\par
\tab private float hauteurMoyennes;\par
\tab private float cumul = 0f;\par
\tab public Song song;\par
\par
\tab public AudioProcessor audioProcessor ;\par
\tab public AudioProcessor micProcessor ;\par
\tab public CubeTunnel tunnel;\par
\tab private CubeInfo[,] _cubeCone1Array;\par
\tab private CubeInfo[,] _cubeCone2Array;\par
\tab //private CubeInfo[,] _cubeCylinderArray;\par
\tab private CubeInfo[,] _cubeCenterArray;\par
\par
\tab private float[] flexion_t;\par
\tab private bool[] flexionDone;\par
\tab private bool[] firstFlexFrame;\par
\tab private float[] ampFlexion;\par
\tab private float[] freqFactorY;\par
\par
\tab public TunnelSpinner TunnelSpinner;\par
\tab\par
\tab // Use this for initialization\par
\tab void Start () \{\par
\tab\tab _cubeCone1Array = tunnel.cubeCone1Array;\par
\tab\tab _cubeCone2Array = tunnel.cubeCone2Array;\par
\tab\tab //_cubeCylinderArray = tunnel.cubeCylinderArray;\par
\tab\tab _cubeCenterArray = tunnel.cubeCenterArray;\par
\tab\tab micProcessor.enabled = false;\par
\par
\tab\tab flexionDone = new bool[song.flexion_t.Length];\par
\tab\tab firstFlexFrame= new bool[song.flexion_t.Length];\par
\tab\tab ampFlexion = new float[song.flexion_t.Length];\par
\tab\tab freqFactorY = new float[song.flexion_t.Length];\par
\par
\tab\tab for (int i = 0; i<song.flexion_t.Length; i++)\{\par
\tab\tab\tab flexionDone[i] = false;\par
\tab\tab\tab firstFlexFrame[i] = true;\par
\tab\tab\tab freqFactorY[i] = UnityEngine.Random.Range(0.2f, 2f);\par
\tab\tab\}\par
\par
\par
\tab\}\par
\tab\par
\tab // Update is called once per frame\par
\tab void Update () \{\par
\par
\tab\tab hauteurBasses = HauteurCube( 0 );\par
\tab\tab hauteurMoyennes = HauteurCube( 1 );\par
\tab\tab hauteurAigues = HauteurCube( 2 );\par
\par
\par
\tab\tab // On applique les trucs a la premiere rang\'e9e\par
\tab\tab ApplyFirstRow(_cubeCone1Array, hauteurBasses, hauteurMoyennes, hauteurAigues);\par
\tab\tab CopyFirstRow (_cubeCone1Array, _cubeCone2Array, 0, 1);\par
\tab\tab CopyFirstRow (_cubeCone1Array, _cubeCenterArray, 0, _cubeCenterArray.GetLength(1));\par
\par
\par
\tab\tab // --------------------------- S C A L E !  ----------------------------------\par
\tab\tab // On transmet le scale de rang\'e9e en rang\'e9e\par
\tab\tab ApplyScaleWave(_cubeCone1Array);\par
\tab\tab ApplyScaleWave(_cubeCone2Array);\par
\tab\tab\par
\tab\tab // --------------------------------***************---------------------------------\par
\tab\tab // --------------------------------------------------------------------------------\par
\par
\par
\tab\tab // --------------------------- C O U L E U R ----------------------------------\par
\tab\tab // On transmet la couleur de rang\'e9e en rang\'e9e\par
\tab\tab ApplyColorWave (_cubeCone1Array);\par
\tab\tab ApplyColorWave (_cubeCone2Array);\par
\tab\tab\par
\tab\tab // --------------------------------***************---------------------------------\par
\tab\tab // --------------------------------------------------------------------------------\par
\par
\par
\tab\tab // ------------------------F L E X I O N   T U N N E L ------------------------------\par
\tab\tab // Make the tunnel bend after the specified time\par
\tab\tab for (int i=0; i<flexionDone.Length;i++)\{\par
\tab\tab\tab if (Time.time >song.flexion_t[i] && !flexionDone[i]) \{\par
\par
\tab\tab\tab\tab if (song.flexion_length[i] < 4) \{\par
\tab\tab\tab\tab\tab Debug.Log("A song.flexion_length is too short. It is ignored");\par
\tab\tab\tab\tab\}\par
\tab\tab\tab\tab else \{\par
\par
\tab\tab\tab\tab\par
\tab\tab\tab\tab flexionDone[i] = flexTunnel(_cubeCone1Array,_cubeCone2Array,Mathf.Sin ((Time.time-song.flexion_t[i])*1.0f)/100,\tab\par
\tab\tab\tab\tab                             Mathf.Sin ((Time.time-song.flexion_t[i])*freqFactorY[i])/100, i);\par
\tab\tab\tab\tab\}\par
\tab\tab\tab\}\par
\tab\tab\}\par
\par
\tab\tab // --------------------------------***************---------------------------------\par
\tab\tab // --------------------------------------------------------------------------------\par
\tab\tab // \par
\par
\tab\tab //On overwrite audioProcessor et remplace par le micro\par
\tab\tab if(Time.time > song.songTime)\par
\tab\tab\{\par
\tab\tab\tab micProcessor.enabled = true;\par
\tab\tab\tab audioProcessor = micProcessor;\par
\tab\tab\}\par
\par
\tab\}\par
\tab\par
\tab\par
\tab float HauteurCube( int range )\{\par
\tab\tab // range :\par
\tab\tab // Basses -> 0\par
\tab\tab // Mids   -> 1\par
\tab\tab // Aigues -> 2\par
\par
\tab\tab int cuton = 0;\par
\tab\tab int cutoff = 0;\par
\tab\tab float scale = 0f;\par
\tab\tab float[] amplitudes;\par
\tab\tab //float cumul = 0f;\par
\tab\tab float moy;\par
\tab\tab float hauteur;\par
\par
\tab\tab // Selection des parametres\par
\tab\tab switch ( range )\par
\tab\tab\{\par
\tab\tab case 0 :\par
\tab\tab\tab cuton = 0;\par
\tab\tab\tab cutoff = 8;\par
\tab\tab\tab scale = 120f;\par
\tab\tab\tab break;\par
\tab\tab case 1 :\par
\tab\tab\tab cuton = 16;\par
\tab\tab\tab cutoff = 128;\par
\tab\tab\tab scale = 720f;\par
\tab\tab\tab break;\par
\tab\tab case 2 :\par
\tab\tab\tab cuton = 512;\par
\tab\tab\tab cutoff = 1024;\par
\tab\tab\tab scale = 12000f;\par
\tab\tab\tab break;\par
\tab\tab default :\par
\tab\tab\tab amplitudes = new float[1];\par
\tab\tab\tab Debug.LogError("range doit etre entre 0 et 2");\par
\tab\tab\tab break;\par
\tab\tab\}\par
\par
\tab\tab // moyenne du range de la FFT\par
\tab\tab amplitudes = new float[cutoff-cuton];\par
\tab\tab Array.Copy(audioProcessor.amplitudes, cuton, amplitudes, 0, cutoff-cuton);\par
\tab\tab moy = scale * amplitudes.Average ();\par
\par
\tab\tab // application de la transformation mathematique\par
\tab\tab cumul = 0.90f * cumul + 0.3f * Tanh (moy);\par
\tab\tab hauteur = (0.4f * cumul +  0.3f*(moy) );\par
\tab\tab if (hauteur < 0.1f)\par
\tab\tab\tab hauteur = 0.1f;\par
\par
\tab\tab return hauteur;\par
\tab\}\tab\par
\par
\tab float Tanh( float x )\{\par
\tab\tab float exp2x = Mathf.Exp(x-5f);\par
\tab\tab return 0.5f*(exp2x-1f)/(exp2x+1f)+0.5f;\par
\tab\}\par
\par
\tab void ApplyFirstRow(CubeInfo[,] cubes, float hauteurBasses, float hauteurMoyennes, float hauteurAigues)\par
\tab\{\par
\tab\tab //On effecte la premiere rang\'e9e des cubes du plancher (depth = 0)\par
\tab\tab int largeur = cubes.GetLength(0);\par
\tab\tab int idxMidRight = 0;\par
\tab\tab int idxGraves = 3*largeur/4;\par
\tab\tab int idxMidLeft = largeur/2;\par
\tab\tab int idxAigues = largeur/4;\par
\tab\tab float ampli = 0.1f;\par
\tab\tab float g = 0f;\par
\tab\tab float r = 0f;\par
\tab\tab float b = 0f;\tab\par
\tab\tab float timeSin=Mathf.Sin(Time.time/7f);\par
\tab\tab float fastTime=Mathf.Sin(Time.time*2);\par
\par
\tab\tab ///Valeurs connues:\par
\tab\tab /// MidsR:\par
\tab\tab cubes[idxMidRight,0].lastScale = cubes[idxMidRight,0].transform.localScale.y;\par
\tab\tab cubes[idxMidRight,0].transform.localScale = new Vector3( cubes[idxMidRight,0].jWidth, hauteurMoyennes, 1f) ;\par
\tab\tab cubes[idxMidRight,0].lastColor = cubes[idxMidRight,0].renderer.material.GetColor("_Color");\par
\tab\tab ampli = cubes[idxMidRight,0].transform.localScale.y;\par
\tab\tab g =  ((timeSin*0.7f) * (ampli/6f))-0.4f;\par
\tab\tab r = (ampli/6f) - (g);\par
\tab\tab b = 0.8f - (ampli/3);\tab\par
\tab\tab cubes[idxMidRight,0].renderer.material.SetColor("_Color", new Color(r,g,b));\par
\par
\par
\tab\tab //MidsL\par
\tab\tab cubes[idxMidLeft,0].lastScale = cubes[idxMidLeft,0].transform.localScale.y;\par
\tab\tab cubes[idxMidLeft,0].transform.localScale = new Vector3( cubes[idxMidLeft,0].jWidth, hauteurMoyennes, 1f) ;\par
\tab\tab cubes[idxMidLeft,0].lastColor = cubes[idxMidLeft,0].renderer.material.GetColor("_Color");\par
\tab\tab ampli = cubes[idxMidLeft,0].transform.localScale.y;\par
\tab\tab g = ((timeSin*0.7f) * (ampli/6f))-0.4f;\par
\tab\tab r = (ampli/6f) - (0.8f*g);\par
\tab\tab b = 0.8f - (ampli/3);\tab\par
\tab\tab cubes[idxMidLeft,0].renderer.material.SetColor("_Color", new Color(r,g,b));\par
\par
\tab\tab // Graves:\par
\tab\tab cubes[idxGraves,0].lastScale = cubes[idxGraves,0].transform.localScale.y;\par
\tab\tab cubes[idxGraves,0].transform.localScale = new Vector3( cubes[idxGraves,0].jWidth, hauteurBasses, 1f) ;\par
\tab\tab cubes[idxGraves,0].lastColor = cubes[idxGraves,0].renderer.material.GetColor("_Color");\par
\tab\tab ampli = cubes[idxGraves,0].transform.localScale.y;\par
\tab\tab g = ((0.8f - ((timeSin*0.7f) * (ampli/6)))-0.2f);\par
\tab\tab r = (ampli/4f) - (0.8f*g);\par
\tab\tab b = 0.8f - (ampli/3);\tab\par
\tab\tab cubes[idxGraves,0].renderer.material.SetColor("_Color", new Color(r,g,b));\par
\par
\tab\tab // Aigues:\par
\tab\tab cubes[idxAigues,0].lastScale = cubes[idxAigues,0].transform.localScale.y;\par
\tab\tab cubes[idxAigues,0].transform.localScale = new Vector3( cubes[idxAigues,0].jWidth, hauteurAigues, 1f) ;\par
\tab\tab cubes[idxAigues,0].lastColor = cubes[idxAigues,0].renderer.material.GetColor("_Color");\par
\tab\tab ampli = cubes[idxAigues,0].transform.localScale.y;\par
\tab\tab g = (ampli/4f);\par
\tab\tab r = 0.4f*fastTime - (ampli/6);\par
\tab\tab b = 0.5f - (ampli/6);\tab\par
\tab\tab cubes[idxAigues,0].renderer.material.SetColor("_Color", new Color(r,g,b));\par
\par
\tab\tab float prop1 = 0f;\par
\tab\tab float prop2 = 0f;\par
\par
\par
\tab\tab //interpoller:\par
\tab\tab float scale = 0f;\par
\tab\tab int dist = idxAigues - idxMidRight;\par
\tab\tab for(int i = idxMidRight+1; i<idxAigues; i++)\{\par
\tab\tab\tab cubes[i,0].lastScale = cubes[i,0].transform.localScale.y;\par
\par
\tab\tab\tab prop1 = (1f - (float)(i-idxMidRight)/dist);\par
\tab\tab\tab prop2 = 1f-prop1;\par
  \tab\tab\tab scale = (prop1*hauteurMoyennes) + (prop2*hauteurAigues);\par
\tab\tab\tab cubes[i,0].transform.localScale = new Vector3( cubes[i,0].jWidth, scale, 1f) ;\par
\par
\tab\tab\tab r = prop1*cubes[idxMidRight,0].renderer.material.GetColor("_Color").r + prop2*cubes[idxAigues,0].renderer.material.GetColor("_Color").r;\par
\tab\tab\tab g = prop1*cubes[idxMidRight,0].renderer.material.GetColor("_Color").g + prop2*cubes[idxAigues,0].renderer.material.GetColor("_Color").g;\par
\tab\tab\tab b = prop1*cubes[idxMidRight,0].renderer.material.GetColor("_Color").b + prop2*cubes[idxAigues,0].renderer.material.GetColor("_Color").b;\par
\tab\tab\tab cubes[i,0].lastColor = cubes[i,0].renderer.material.GetColor("_Color");\par
\tab\tab\tab cubes[i,0].renderer.material.SetColor("_Color", new Color(r,g,b));\par
\par
\tab\tab\}\par
\par
\tab\tab dist = idxMidLeft - idxAigues;\par
\tab\tab for(int i = idxAigues+1; i<idxMidLeft; i++)\{\par
\tab\tab\tab cubes[i,0].lastScale = cubes[i,0].transform.localScale.y;\par
\par
\tab\tab\tab prop1 = (1f - (float)(i-idxAigues)/dist);\par
\tab\tab\tab prop2 = 1f-prop1;\par
\tab\tab\tab scale = (prop1*hauteurAigues) + (prop2*hauteurMoyennes);\par
\tab\tab\tab cubes[i,0].transform.localScale = new Vector3( cubes[i,0].jWidth, scale, 1f) ;\par
\par
\par
\tab\tab\tab r = prop1*cubes[idxAigues,0].renderer.material.GetColor("_Color").r + prop2*cubes[idxMidLeft,0].renderer.material.GetColor("_Color").r;\par
\tab\tab\tab g = prop1*cubes[idxAigues,0].renderer.material.GetColor("_Color").g + prop2*cubes[idxMidLeft,0].renderer.material.GetColor("_Color").g;\par
\tab\tab\tab b = prop1*cubes[idxAigues,0].renderer.material.GetColor("_Color").b + prop2*cubes[idxMidLeft,0].renderer.material.GetColor("_Color").b;\par
\tab\tab\tab cubes[i,0].lastColor = cubes[i,0].renderer.material.GetColor("_Color");\par
\tab\tab\tab cubes[i,0].renderer.material.SetColor("_Color", new Color(r,g,b));\par
\tab\tab\}\par
\par
\tab\tab dist = idxGraves - idxMidLeft;\par
\tab\tab for(int i = idxMidLeft+1; i<idxGraves; i++)\{\par
\tab\tab\tab cubes[i,0].lastScale = cubes[i,0].transform.localScale.y;\par
\par
\tab\tab\tab prop1 = (1f - (float)(i-idxMidLeft)/dist);\par
\tab\tab\tab prop2 = 1f-prop1;\par
\tab\tab\tab scale = (prop1*hauteurMoyennes) + (prop2*hauteurBasses);\par
\tab\tab\tab cubes[i,0].transform.localScale = new Vector3( cubes[i,0].jWidth, scale, 1f) ;\par
\par
\tab\tab\tab r = prop1*cubes[idxMidLeft,0].renderer.material.GetColor("_Color").r + prop2*cubes[idxGraves,0].renderer.material.GetColor("_Color").r;\par
\tab\tab\tab g = prop1*cubes[idxMidLeft,0].renderer.material.GetColor("_Color").g + prop2*cubes[idxGraves,0].renderer.material.GetColor("_Color").g;\par
\tab\tab\tab b = prop1*cubes[idxMidLeft,0].renderer.material.GetColor("_Color").b + prop2*cubes[idxGraves,0].renderer.material.GetColor("_Color").b;\par
\tab\tab\tab cubes[i,0].lastColor = cubes[i,0].renderer.material.GetColor("_Color");\par
\tab\tab\tab cubes[i,0].renderer.material.SetColor("_Color", new Color(r,g,b));\par
\tab\tab\}\par
\par
\tab\tab dist = largeur - idxGraves;\par
\tab\tab for(int i = idxGraves+1; i<largeur; i++)\{\par
\tab\tab\tab cubes[i,0].lastScale = cubes[i,0].transform.localScale.y;\par
\par
\tab\tab\tab prop1 = (1f - (float)(i-idxGraves)/dist);\par
\tab\tab\tab prop2 = 1f-prop1;\par
\tab\tab\tab scale = (prop1*hauteurBasses) + (prop2*hauteurMoyennes);\par
\tab\tab\tab cubes[i,0].transform.localScale = new Vector3( cubes[i,0].jWidth, scale, 1f) ;\par
\par
\tab\tab\tab r = prop1*cubes[idxGraves,0].renderer.material.GetColor("_Color").r + prop2*cubes[idxMidRight,0].renderer.material.GetColor("_Color").r;\par
\tab\tab\tab g = prop1*cubes[idxGraves,0].renderer.material.GetColor("_Color").g + prop2*cubes[idxMidRight,0].renderer.material.GetColor("_Color").g;\par
\tab\tab\tab b = prop1*cubes[idxGraves,0].renderer.material.GetColor("_Color").b + prop2*cubes[idxMidRight,0].renderer.material.GetColor("_Color").b;\par
\tab\tab\tab cubes[i,0].lastColor = cubes[i,0].renderer.material.GetColor("_Color");\par
\tab\tab\tab cubes[i,0].renderer.material.SetColor("_Color", new Color(r,g,b));\par
\tab\tab\}\par
\par
\tab\}\par
\par
\tab void CopyFirstRow(CubeInfo[,] original, CubeInfo[,] copy, int z0, int nZ)\{\par
\tab\tab for (int i = 0; i<original.GetLength(0); i++) \{\par
\tab\tab\tab for (int j = z0; j<(z0+nZ); j++) \{\par
\tab\tab\tab\tab copy[i,j].lastScale = original[i,0].lastScale;\par
\tab\tab\tab\tab copy[i,j].transform.localScale = original[i,0].transform.localScale;\par
\tab\tab\tab\tab copy[i,j].lastColor = original[i,0].lastColor;\par
\tab\tab\tab\tab copy[i,j].renderer.material.SetColor("_Color",original[i,0].renderer.material.GetColor("_Color"));\par
\par
\tab\tab\tab\}\par
\tab\tab\}\par
\tab\}\par
\par
\tab void ApplyScaleWave(CubeInfo[,] cubes)\{\par
\par
\tab\tab for(int i = 0; i<cubes.GetLength(0); i++)\{\par
\tab\tab\tab for(int j = 1; j<cubes.GetLength(1); j++)\tab\{\par
\tab\tab\tab\tab //Le jratio sert a prendre en compte l'effet conique. Si on ne divisait pas par jratio, \par
\tab\tab\tab\tab //on aurait l'impression que les scale augmente avec la profondeur\par
\tab\tab\tab\tab cubes[i,j].lastScale = cubes[i,j].transform.localScale.y / cubes[i,j].jRatio;\par
\tab\tab\tab\tab cubes[i,j].transform.localScale = new Vector3( cubes[i,j].jWidth, cubes[i,j].jRatio * cubes[i,j-1].lastScale, 1f) ;\par
\tab\tab\tab\}\par
\tab\tab\}\par
\tab\} \par
\par
\tab private bool flexTunnel(CubeInfo[,] cubes1,CubeInfo[,] cubes2, float sinOffsetX, float sinOffsetY, int flexionID)  \{\tab\par
\par
\tab\tab bool flexionDone = false;\par
\tab\tab float amp =1000;\par
\par
\tab\tab // Si c'est la premiere frame de cette flexion, avertir TunnelSpinner pour qu'il cesse d'enregistrer la position\par
\tab\tab if (firstFlexFrame[flexionID]==true) \{\par
\tab\tab\tab firstFlexFrame[flexionID] = false;\par
\tab\tab\tab TunnelSpinner.startFlexion();\par
\tab\tab\}\par
\par
\tab\tab if ((Time.time - song.flexion_t[flexionID])<Mathf.Min (2,song.flexion_length[flexionID]/3)) \{\par
\tab\tab\tab // La force d'amplication du sinus commence a 0 et augmente jusqu'a 4 \par
\tab\tab\tab amp = (Time.time-song.flexion_t[flexionID])/2;\par
\par
\tab\tab\}\par
\tab\tab else if ((Time.time - song.flexion_t[flexionID])<(song.flexion_length[flexionID]-4))  \{\par
\tab\tab\tab\par
\tab\tab\tab amp =1;\par
\tab\tab\}\par
\tab\tab else \{\par
\tab\tab\tab // La force d'amplication du sinus diminue jusqu'a 0 (parabole invers\'e9e)\par
\tab\tab\tab amp = Mathf.Max ((song.flexion_length[flexionID]-(Time.time-song.flexion_t[flexionID]))/4,0);\par
\tab\tab\}\par
\par
\tab\tab for(int i = 0; i<cubes1.GetLength(0); i++)\{\par
\tab\tab\tab for(int j = 1; j<cubes1.GetLength(1); j++)\{\par
\tab\tab\tab\tab cubes1[i,j].transform.position = new Vector3 ((cubes1[i,j].posSansFlexion.x+ amp*Mathf.Pow(j,2)*sinOffsetX),cubes1[i,j].posSansFlexion.y + amp*Mathf.Pow(j,2)*sinOffsetY,cubes1[i,j].transform.position.z);\par
\tab\tab\tab\}\par
\tab\tab\}\par
\tab\tab for(int i = 0; i<cubes2.GetLength(0); i++)\{\par
\tab\tab\tab for(int j = 1; j<cubes2.GetLength(1); j++)\{\par
\tab\tab\tab\tab cubes2[i,j].transform.position = new Vector3 ((cubes2[i,j].posSansFlexion.x+ amp*Mathf.Pow(j,2)*sinOffsetX),cubes2[i,j].posSansFlexion.y+ amp*Mathf.Pow(j,2)*sinOffsetY,cubes2[i,j].transform.position.z);\par
\tab\tab\tab\}\par
\tab\tab\}\par
\tab\tab // Stop the flexion script when amp and the offset are small\par
\tab\tab if (amp < 0.0001f)\{\tab\par
\tab\tab\tab flexionDone = true;\par
\tab\tab\tab ApplyDefaultPosition(_cubeCone1Array);\par
\tab\tab\tab ApplyDefaultPosition(_cubeCone2Array);\par
\tab\tab\}\par
\tab\tab return flexionDone;\par
\tab\}\par
\tab\par
\par
\tab void ApplyDefaultPosition(CubeInfo[,] cubes)  \{\tab\par
\tab\tab TunnelSpinner.endFlexion();\par
\tab\tab for(int i = 0; i<cubes.GetLength(0); i++)\{\par
\tab\tab\tab for(int j = 1; j<cubes.GetLength(1); j++)\{\par
\tab\tab\tab\tab cubes[i,j].transform.position = cubes[i,j].posSansFlexion;\par
\par
\tab\tab\tab\}\par
\tab\tab\}\par
\tab\}\par
\par
\tab void ApplyColorWave(CubeInfo[,] cubes)\{\par
\tab\tab for(int i = 0; i<cubes.GetLength(0); i++)\{\par
\tab\tab\tab for(int j = 1; j<cubes.GetLength(1); j++)\{\par
\tab\tab\tab\tab cubes[i,j].lastColor = cubes[i,j].renderer.material.GetColor("_Color");\par
\tab\tab\tab\tab cubes[i,j].renderer.material.SetColor("_Color", cubes[i,j-1].lastColor);\par
\tab\tab\tab\}\par
\tab\tab\}\par
\tab\}\par
\}\par
}
 